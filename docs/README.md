### 기본 체크리스트

- [x] Constant 초안 작성 (README 줄 번호 주석)
- [x] 명사 <> 동사 관계를 찾아 객체지향적으로 구조 설계하기
- 설계 내용에 따라 도메인 구현
  - [ ] `Calculator`
  - [ ] `Lexer`
    - [x] 기본 구분자 처리
    - [x] 단일 커스텀 구분자 처리
    - [ ] 복합 커스텀 구분자 처리
  - [x] `Token`
- [ ] ErrorCode enum
- [ ] view.Message
- [ ] 단위 테스트로 로직 검증
- [ ] InputView 구현
- [ ] OutputView 구현

# 설계하기

- 정수라 안 하고 숫자라 했기 때문에 실수를 포함할 것인지를 정해야함
- 우선 입력은 반드시 정수여야 한다는 제약을 토대로 진행
- 컴파일러 이론에 따라 Lexer와 Parser 분리

## 계산기

1. 정수 배열이 주어졌을 때, 모두 더하는 private 함수
2. 문자열 -> 숫자들 추출 (Parser)
   - 커스텀 구분자
   - 기본 구분자
3. 계산기는 내부에 토큰화 기계를 포함한다.

### 토큰화 기계 (Lexer)

> 커스텀 구분자는 문자열 앞부분의 "//"와 "\n" 사이에 위치하는 문자를 커스텀 구분자로 사용한다.
> `문자열`이 아닌 `문자`라고 명시했으므로, 구분자는 `char`로 표현할 수 있는 1 바이트 문자라고 판단

1. 문자열을 받으면 토큰의 배열로 변형
   - 내부에 스택 보유
   - 최초에 기본 구분자로 클래스 초기화
   - 메서드에 문자열 넘기면 스택 생성
   - 이후 순차적으로 스택에 push
     - 구분자 만나면 스택이 빌 때까지 pop하고 전부 퉁쳐서 숫자 하나로 결과에 반영
     - 문자를 만날 때마다 등록된 구분자를 만나면 치환
     - 커스텀 접미사를 만나면,
       접두사를 만나기 전까지 stack에서 pop
       전부 StringBuilder에 넣고 커스텀 구분자로 퉁치기
       - 이후 해당 커스텀 구분자도 구분자에 등록
       <!-- - 그리고 커스텀 구분자는 현재 인덱스 이후의
         String.replace로 기본 구분자로 변환 후 로직 계속 진행 -->
2. 제대로 동작하는 지 확인하려면 `1,21:13//;\n1;21;13` = 90 

### 토큰 (Token)

`//` 또는 `\n` 같은 다수의 문자 집합(문자열)을 단위로 삼아 의미를 부여하려면 열거형 필요
