# 과제 진행 요구 사항

- 기능을 구현하기 전 README.md에 구현할 기능 목록을 정리해 추가한다.
- Git의 커밋 단위는 앞 단계에서 README.md에 정리한 기능 목록 단위로 추가한다.
- 2일차: 반드시 `Token` 인터페이스를 활용하여 구현하시오.

# 기능 요구 사항 정리

- 라인 31: 입력은 구분자와 양수로 구성된 문자열
- 기본 구분자 = 쉼표 콜론
- 커스텀 구분자 = 문자열 앞부분의 "//"와 "\n" 사이에 위치하는 문자

## 의문점

1. 라인 21: `기본 구분자를 가지는 문자열을 전달하는 경우`: `경우`라는 표현은 기본 구분자와 커스텀 구분자가 서로 양립할 수 없는 관계임을 전달하고자 사용된 것인가? **MAYBE**
   - 만약 그렇다면, 기본 구분자가 정의된 문자열에서는 커스텀 구분자를 정의할 수 없고, 그 역도 성립한다.
2. 라인 23: `앞의 기본 구분자 외에 커스텀 구분자를 지정할 수 있다.`: **커스텀 구분자는 기본 구문자이어서는 안 된다.**
3. 라인 23: `문자열 앞부분`: '문자열'이라는 것이 입력으로 들어온 전체 문자열인가? **MAYBE**
   - 만약 그렇다면, 커스텀 구분자의 유무는 반드시 문자열 최초 5바이트 선에서 가능하다.
   - 다른 가능성은 `부분 문자열`에 대해서도 성립해야 한다는 가정이다. 이 가정은 뒷받침하는 근거가 빈약하다.
   1. 귀류법을 통해 만약 지칭한 문자열이 최초에 입력된 `전체 문자열`이 아니라면, 라인 23의 `앞부분`이라는 표현은 수식할 대상 `부분 문자열`이 특정되지 않은 상태에서는 사용할 수 없다고 생각한다.
   2. 이외에도 문자열이 특정된 시점이 존재했는지 조사해보면, 최초 언급된 `입력한 문자열`이 라인 21에서 `전달하는 경우`로 이어졌고, 라인 23은 라인 21에 대해 `앞의 (경우) 외에`라는 표현으로 서로 대응되는 구성을 취하고 있다는 것을 보았을 때, `앞부분`이라는 표현은 `최초 입력하여 전달한 문자열`을 수식한다고 해석할 수 있는 여지가 있다.
4. 라인 23: 문자열과 구분지어 `문자`라는 표현을 의도적으로 사용했는가? **YES**
   - 만약 그렇다면, 커스텀 구분자는 반드시 1 Byte char로 온전히 표현 가능해야 한다.
5. `ApplicationTest::예외_테스트`: "-1,2,3"이라는 문자열은 입력 오류이어야 한다.
   - 라인 31: 구분자와 **양수**로 구성된 문자열
   - 명시적으로 입력된 "0" 또한 입력 오류이어야 한다.
6. 라인 19: `입력한 문자열에서 숫자를 추출` & 라인 31: `구분자와 양수로 구성된 문자열`: 입력된 숫자는 `양의 실수`일 가능성도 있는가? **MAYBE**
   - 양수 조건은 있으나, 정수 조건은 찾을 수 없다.

### 입력 제약 사항 요약

1. 입력은 문자열이다.
2. 문자열은 `양수`와 구분자로 구성된다.
   - 양수 조건에 의해, 명시적으로 입력된 `0` 또한 입력 오류이다.
   - 명시적인 정수 조건이 없어, '.' 문자가 사용될 경우, 이를 실수에 대한 표현으로 해석해야 할지 확실한 판단이 어렵다.
3. 문자열의 앞부분에 커스텀 구분자 정의 문법을 사용하면 구분자를 정의할 수 있다.
   - 그러나 정의 가능 횟수나 복합적인 구분자 활용에 대해서는 확실한 판단이 어렵다.

### 결정 사항

1. 문자열은 `양의 실수`와 구분자로 구성된다.
   - "3,3"과 같이 양의 정수로만 구성되었다면 결과는 `BigInteger`로 반환된다.
   - "3.3"과 같이 실수가 포함되었다면 결과는 `BigDecimal`에 반환된다.
2. 양수의 덧셈을 수행한 결과가 음수가 나온다면, 별도의 예외를 반환해야 한다.
3. Java 리터럴 표기법에 따라 "3."와 같이 소수부를 생략한 표현도 실수로 취급한다.
4. 구분자는 반드시 수를 구분하는 용도로 사용되어야 한다.
   - 예를 들어, "," , "3,", ",3", ",3," 와 같은 입력은 유효하지 않은 것으로 판단한다.
5. 커스텀 구분자로는 기본 구분자 외 `모든 출력 가능한 문자`를 허용한다.
   - 출력 불가능한 문자로 커스텀 구분자를 정의할 경우, 입력 예외가 발생한다.
6. 커스텀 구분자의 정의부를 식별한 경우, 이후의 부분 문자열은 현재의 상태가 보존된, 독립적인 문자열로 평가한다.
   - 예를 들어, `"//;\n1//a\n2;3"`의 평가는 `"//;\n1"`와 `"//a\n2;3"`, 각각의 평가 결과를 일반 구분자로 이어 평가한 결과와 같다.
7. 문자열에 대한 평가는 문자의 순서에 따라 순차적으로 이루어진다.
8. 소숫점 구분 표현 온점 '.'이 사용되었을 경우는 2가지로 나누어 생각한다.
   - 커스텀 구분자로 온점이 사용되었다면, 해당 문자를 구분자로 취급한다.
   - 그 외의 경우에는 실수의 소수부 표현으로 취급한다.

# 설계

> 모든 요소를 `Token`화하고, `reduce` 연산을 통해 결과를 도출하자

## CHAR_TOKEN 문자 토큰 (final)

- 출력 불가능한 문자가 사용된 경우, 오류를 반환한다.
- 그 외에는 내부에 문자를 캡슐화한다.
- reduce 방식이 특수한 경우
  - '/' 토큰은 다음 토큰이 '/'인 경우, 커스텀*구분자*접두사\_토큰이 된다.
  - '\' 토큰은 다음 토큰이 '\n'인 경우, 커스텀*구분자*접미사\_토큰이 된다.

### 특수한 문자 토큰 (enum; equals(Token))

1. DOT_TOKEN
2. SLASH_TOKEN
3. REVERSE_SLASH_TOKEN
4. LOWER_ALPHABET_N

### 기타 토큰 (implements Token)

2. 정수 토큰
   - `BigInteger`
   - ASCII '0'에서 '9' 문자는 정수 토큰이 된다.
   - 정수 토큰이 DOT_TOKEN을 만나면 실수 토큰으로 변한다.
3. 실수 토큰
   - `BigDecimal`
4. 구분자 토큰
5. 커스텀*구분자*접두사\_토큰
   -
6. 커스텀*구분자*접두사*문자*토큰
   - 인자에 커스텀*구분자*접미사*토큰이 오면 빈*컨텍스트\_토큰으로 초기화합니다.
   - 이외의 모든 토큰에 오류를 반환합니다.
7. 커스텀*구분자*접미사\_토큰
   - reduce 파라미터는 즉시 오류를 반환합니다.
   - 반드시 커스텀*구분자*접두사*문자*토큰으로 소비되어야만 합니다.
8. 빈*컨텍스트*토큰
   - 인자를 그대로 반환합니다.
