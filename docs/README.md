### 기본 체크리스트

- [x] Constant 초안 작성 (README 줄 번호 주석)
- [x] 명사 <> 동사 관계를 찾아 객체지향적으로 구조 설계하기
- 설계 내용에 따라 도메인 구현
  - [x] `Calculator`
    - [x] 문자열을 받아 내부 숫자를 모두 더하는 기능
  - [x] `Lexer`
    - [x] 기본 구분자 처리
    - [x] 단일 커스텀 구분자 처리
    - [x] 복합 커스텀 구분자 처리
    - [x] 예외 테스트 반영
      - `"-1,2,3"` 가 실패를 반환해야 할 때, 추론 가능한 전제는
        1.  음수를 허용하지 않거나
        2.  숫자 외의 문자는 구분자로 등록된 이후에만 사용 가능하거나 정도
            (1과 동치; 특수한 규칙을 도입하지 않으면 음수를 표현할 길이 없어짐)
      - 따라서, `모든 수는 음수가 아니다`라는 깔끔한 전제로 테스트 재개
    - [x] 커스텀 구분자는 반드시 1 Byte의 char가 접두사 접미사 사이에 위치한 형태로만 존재해야 한다.
- [x] 입/출력 구현

# 설계하기

- 정수라 안 하고 숫자라 했기 때문에 실수를 포함할 것인지를 정해야함
- 우선 입력은 반드시 정수여야 한다는 제약을 토대로 진행
- 컴파일러 이론에 따라 Lexer와 Parser 분리

## 계산기

1. 문자열이 주어졌을 때, 모두 더하는 public 함수
2. 정수 배열이 주어졌을 때, 모두 더하는 private 함수
3. 계산기는 내부에 `Lexer`를 포함한다.

### 토큰화 기계 (Lexer)

> 커스텀 구분자는 문자열 앞부분의 "//"와 "\n" 사이에 위치하는 문자를 커스텀 구분자로 사용한다.
> `문자열`이 아닌 `문자`라고 명시했으므로, 구분자는 `char`로 표현할 수 있는 1 바이트 문자라고 판단

- `int[] convert(String s)`: 문자열을 받으면 규칙에 따라 정수 배열을 반환한다.
- 정규 표현식과 String 메서드를 활용하여 선형적으로 구현
- `Set<Character> defaultDelims`처럼 기본 구분자 따로 받으면 하드코딩된 정규표현식들 리팩토링 가능
